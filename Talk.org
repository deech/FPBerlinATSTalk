#+TITLE: Why Linear Types Are The Future Of Systems Programming
#+AUTHOR: Aditya Siram
#+OPTIONS: H:2 toc:f
#+OPTIONS: ^:nil
#+LATEX_CLASS: beamer
#+LATEX_listingsCLASS_OPTIONS: [presentation]
#+BEAMER_THEME: metropolis

* Introduction
** Standard Hello World
#+begin_src sml
implement main0 = println! ("hello world")
#+end_src
** List Datatype
- First from the ML side
** List Datatype
- a linear list type
#+begin_src sml
datatype list_vt (a:vt@ype, int) =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list(a, n))
#+end_src

** List Datatype
- probably more familiar (~_vt~ for viewtype)
#+begin_src sml
datatype list_vt                    =
  | list_nil       of ()
  |
    list_cons         of (a, list(a   ))
#+end_src

** List Datatype
- indexed on numbers, dependant types, just like ~(S(S(..)))~
#+begin_src sml
datatype list_vt                    =
  | list_nil(a, 0) of ()
  |
    list_cons(a, n+1) of (a, list(a, n))
#+end_src

** List Datatype
- numbers can be constrained, refinement types!
#+begin_src sml
datatype list_vt                    =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list(a, n))
#+end_src

** List Datatype
- parameterized on a view, linear types!
#+begin_src sml
datatype list_vt (a:vt@ype, int) =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list(a, n))
#+end_src

** List Datatype
- all ADT's are GADT's in ATS
#+begin_src sml
datatype list_vt (a:vt@ype, int) =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list(a, n))
#+end_src
** List Datatype
- tons type level concepts to learn!
- we'll get to some later ...
** Manual Memory Management
- Now from the C side!
** Manual Memory Management
- What resources are leaked?
#+begin_src c
int main(int argc, char** argv) {
  int* i = (int*)malloc(sizeof(int));
  *i = 10;
  FILE* fp = fopen("test.txt","r");
  return 0;
}
#+end_src
** Manual Memory Management
- Memory!
#+begin_src c
int main(int argc, char** argv) {
  int* i = (int*)malloc(sizeof(int)); // <--- LEAK!!
  *i = 10;
  FILE* fp = fopen("test.txt","r");
  return 0;
}
#+end_src
** Manual Memory Management
- File descriptor
#+begin_src c
int main(int argc, char** argv) {
  int* i = (int*)malloc(sizeof(int)); // <--- LEAK!!
  *i = 10;
  FILE* fp = fopen("test.txt","r"); // <-- LEAK!!
  return 0;
}
#+end_src
** Manual Memory Management
- /Equivalent/ ATS program
#+begin_src sml
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset | ()) = ptr_set(pf | i, 10)
  val (pfFile | fp) = fopen("test.txt", "r")
in
  free(pfset | i);
  fclose(pfFile | fp);
end
#+end_src
** Manual Memory Management
- "Client-facing" code, analogous, safe, this is why ATS is "fast"
#+begin_src c
implement main0 () = let
  val (     i) = malloc (sizeof<int>)
  val (        ()) = ptr_set(     i, 10)
  val (         fp) = fopen("test.txt", "r")
in
  free(        i);
  fclose(         fp);
end
#+end_src
** Manual Memory Management
- ~malloc~ /produces/ a linear proof ~pf~, /consumed/ by ~ptr_set~
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (      | ()) = ptr_set(pf | i, 10)
  val (         fp) = fopen("test.txt", "r")
in
  free(        i);
  fclose(         fp);
end
#+end_src
** Manual Memory Management
- ~ptr_set~ /produces/ a proof ~pfset~
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset | ()) = ptr_set(pf | i, 10)
  val (       | fp) = fopen("test.txt", "r")
in
  free(        i);
  fclose(         fp);
end
#+end_src
** Manual Memory Management
- ~fopen~ produces a proof of the file descriptor ~pfFile~
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset | ()) = ptr_set(pf | i, 10)
  val (pfFile | fp) = fopen("test.txt", "r")
in
  free(pfset | i);
  fclose(pfFile | fp);
end
#+end_src
** Manual Memory Management
- What happens when ~free~ and ~fopen~ are deleted?
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset | ()) = ptr_set(pf | i, 10)
  val (pfFile | fp) = fopen("test.txt", "r")
in


end
#+end_src
** Manual Memory Management
- ~pfset~ is left unconsumed
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset <---
  val (pfFile | fp) = fopen("test.txt", "r")
in


end
#+end_src
** Manual Memory Management
- ~pfFile~ is left unconsumed
#+begin_src c
implement main0 () = let
  val (pf | i) = malloc (sizeof<int>)
  val (pfset <---
  val (pfFile <---
in


end
#+end_src
** Manual Memory Management
- Free to write your all your code this way!
  - safe from buffer overflows & pointer bugs
  - ... there's sugar for implicitly passing proofs around
- Reuse decades of design sensibilities (safely!)
- But you're not benefitting from Functional Programmingâ„¢...
